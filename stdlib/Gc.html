<div class="ocaml_toplevel_module">
<div class="info">Memory management control and statistics; finalised values.</div>
<pre><code><span id="TYPEstat"><span class="keyword">type</span> stat</span> = {</code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code> <span id="TYPEELTstat.minor_words">minor_words</span> :<code class="type">float</code>;</code></td><td class="typefieldcomment" align="left">Number of words allocated in the minor heap since
       the program was started.  This number is accurate in
       byte-code programs, but only an approximation in programs
       compiled to native code.</td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code> <span id="TYPEELTstat.promoted_words">promoted_words</span> :<code class="type">float</code>;</code></td><td class="typefieldcomment" align="left">Number of words allocated in the minor heap that
       survived a minor collection and were moved to the major heap
       since the program was started.</td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code> <span id="TYPEELTstat.major_words">major_words</span> :<code class="type">float</code>;</code></td><td class="typefieldcomment" align="left">Number of words allocated in the major heap, including
       the promoted words, since the program was started.</td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code> <span id="TYPEELTstat.minor_collections">minor_collections</span> :<code class="type">int</code>;</code></td><td class="typefieldcomment" align="left">Number of minor collections since the program was started.</td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code> <span id="TYPEELTstat.major_collections">major_collections</span> :<code class="type">int</code>;</code></td><td class="typefieldcomment" align="left">Number of major collection cycles completed since the program
        was started.</td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code> <span id="TYPEELTstat.heap_words">heap_words</span> :<code class="type">int</code>;</code></td><td class="typefieldcomment" align="left">Total size of the major heap, in words.</td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code> <span id="TYPEELTstat.heap_chunks">heap_chunks</span> :<code class="type">int</code>;</code></td><td class="typefieldcomment" align="left">Number of contiguous pieces of memory that make up the major heap.</td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code> <span id="TYPEELTstat.live_words">live_words</span> :<code class="type">int</code>;</code></td><td class="typefieldcomment" align="left">Number of words of live data in the major heap, including the header
       words.</td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code> <span id="TYPEELTstat.live_blocks">live_blocks</span> :<code class="type">int</code>;</code></td><td class="typefieldcomment" align="left">Number of live blocks in the major heap.</td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code> <span id="TYPEELTstat.free_words">free_words</span> :<code class="type">int</code>;</code></td><td class="typefieldcomment" align="left">Number of words in the free list.</td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code> <span id="TYPEELTstat.free_blocks">free_blocks</span> :<code class="type">int</code>;</code></td><td class="typefieldcomment" align="left">Number of blocks in the free list.</td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code> <span id="TYPEELTstat.largest_free">largest_free</span> :<code class="type">int</code>;</code></td><td class="typefieldcomment" align="left">Size (in words) of the largest block in the free list.</td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code> <span id="TYPEELTstat.fragments">fragments</span> :<code class="type">int</code>;</code></td><td class="typefieldcomment" align="left">Number of wasted words due to fragmentation.  These are
       1-words free blocks placed between two live blocks.  They
       are not available for allocation.</td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code> <span id="TYPEELTstat.compactions">compactions</span> :<code class="type">int</code>;</code></td><td class="typefieldcomment" align="left">Number of heap compactions since the program was started.</td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code> <span id="TYPEELTstat.top_heap_words">top_heap_words</span> :<code class="type">int</code>;</code></td><td class="typefieldcomment" align="left">Maximum size reached by the major heap, in words.</td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code> <span id="TYPEELTstat.stack_size">stack_size</span> :<code class="type">int</code>;</code></td><td class="typefieldcomment" align="left">Current size of the stack, in words.<b>Since</b> 3.12.0</td>
	  </tr></table>}
      
    
<pre><code><span id="TYPEcontrol"><span class="keyword">type</span> control</span> = {</code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span id="TYPEELTcontrol.minor_heap_size">minor_heap_size</span> :<code class="type">int</code>;</code></td><td class="typefieldcomment" align="left">The size (in words) of the minor heap.  Changing
       this parameter will trigger a minor collection.  Default: 32k.</td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span id="TYPEELTcontrol.major_heap_increment">major_heap_increment</span> :<code class="type">int</code>;</code></td><td class="typefieldcomment" align="left">The minimum number of words to add to the
       major heap when increasing it.  Default: 124k.</td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span id="TYPEELTcontrol.space_overhead">space_overhead</span> :<code class="type">int</code>;</code></td><td class="typefieldcomment" align="left">The major GC speed is computed from this parameter.
       This is the memory that will be &quot;wasted&quot; because the GC does not
       immediatly collect unreachable blocks.  It is expressed as a
       percentage of the memory used for live data.
       The GC will work more (use more CPU time and collect
       blocks more eagerly) if <code class="code">space_overhead</code> is smaller.
       Default: 80.</td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span id="TYPEELTcontrol.verbose">verbose</span> :<code class="type">int</code>;</code></td><td class="typefieldcomment" align="left">This value controls the GC messages on standard error output.
       It is a sum of some of the following flags, to print messages
       on the corresponding events:<ul><li><code class="code">0x001</code> Start of major GC cycle.</li><li><code class="code">0x002</code> Minor collection and major GC slice.</li><li><code class="code">0x004</code> Growing and shrinking of the heap.</li><li><code class="code">0x008</code> Resizing of stacks and memory manager tables.</li><li><code class="code">0x010</code> Heap compaction.</li><li><code class="code">0x020</code> Change of GC parameters.</li><li><code class="code">0x040</code> Computation of major GC slice size.</li><li><code class="code">0x080</code> Calling of finalisation functions.</li><li><code class="code">0x100</code> Bytecode executable search at start-up.</li><li><code class="code">0x200</code> Computation of compaction triggering condition.
       Default: 0. </li></ul></td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span id="TYPEELTcontrol.max_overhead">max_overhead</span> :<code class="type">int</code>;</code></td><td class="typefieldcomment" align="left">Heap compaction is triggered when the estimated amount
       of &quot;wasted&quot; memory is more than <code class="code">max_overhead</code> percent of the
       amount of live data.  If <code class="code">max_overhead</code> is set to 0, heap
       compaction is triggered at the end of each major GC cycle
       (this setting is intended for testing purposes only).
       If <code class="code">max_overhead &gt;= 1000000</code>, compaction is never triggered.
       If compaction is permanently disabled, it is strongly suggested
       to set <code class="code">allocation_policy</code> to 1.
       Default: 500.</td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span id="TYPEELTcontrol.stack_limit">stack_limit</span> :<code class="type">int</code>;</code></td><td class="typefieldcomment" align="left">The maximum size of the stack (in words).  This is only
       relevant to the byte-code runtime, as the native code runtime
       uses the operating system's stack.  Default: 256k.</td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span id="TYPEELTcontrol.allocation_policy">allocation_policy</span> :<code class="type">int</code>;</code></td><td class="typefieldcomment" align="left">The policy used for allocating in the heap.  Possible
        values are 0 and 1.  0 is the next-fit policy, which is
        quite fast but can result in fragmentation.  1 is the
        first-fit policy, which can be slower in some cases but
        can be better for programs with fragmentation problems.
        Default: 0.<b>Since</b> 3.11.0</td>
	  </tr></table>}
      
    
 
      <pre><span><span class="keyword">val</span> stat</span> : <code class="type">unit -&gt; <a href="?package=stdlib&amp;module=Gc&amp;type=stat">stat</a></code></pre>
      
    
 
      <pre><span><span class="keyword">val</span> quick_stat</span> : <code class="type">unit -&gt; <a href="?package=stdlib&amp;module=Gc&amp;type=stat">stat</a></code></pre>
      
    
 
      <pre><span><span class="keyword">val</span> counters</span> : <code class="type">unit -&gt; float * float * float</code></pre>
      
    
 
      <pre><span><span class="keyword">val</span> get</span> : <code class="type">unit -&gt; <a href="?package=stdlib&amp;module=Gc&amp;type=control">control</a></code></pre>
      
    
 
      <pre><span><span class="keyword">val</span> set</span> : <code class="type"><a href="?package=stdlib&amp;module=Gc&amp;type=control">control</a> -&gt; unit</code></pre>
      
    
 
      <pre><span><span class="keyword">val</span> minor</span> : <code class="type">unit -&gt; unit</code></pre>
      
    
 
      <pre><span><span class="keyword">val</span> major_slice</span> : <code class="type">int -&gt; int</code></pre>
      
    
 
      <pre><span><span class="keyword">val</span> major</span> : <code class="type">unit -&gt; unit</code></pre>
      
    
 
      <pre><span><span class="keyword">val</span> full_major</span> : <code class="type">unit -&gt; unit</code></pre>
      
    
 
      <pre><span><span class="keyword">val</span> compact</span> : <code class="type">unit -&gt; unit</code></pre>
      
    
 
      <pre><span><span class="keyword">val</span> print_stat</span> : <code class="type"><a href="?package=stdlib&amp;module=Pervasives&amp;type=out_channel">out_channel</a> -&gt; unit</code></pre>
      
    
 
      <pre><span><span class="keyword">val</span> allocated_bytes</span> : <code class="type">unit -&gt; float</code></pre>
      
    
 
      <pre><span><span class="keyword">val</span> finalise</span> : <code class="type">('a -&gt; unit) -&gt; 'a -&gt; unit</code></pre>
      
    
 
      <pre><span><span class="keyword">val</span> finalise_release</span> : <code class="type">unit -&gt; unit</code></pre>
      
    
<pre><span id="TYPEalarm"><span class="keyword">type</span> alarm</span> </pre>
      
    
 
      <pre><span><span class="keyword">val</span> create_alarm</span> : <code class="type">(unit -&gt; unit) -&gt; <a href="?package=stdlib&amp;module=Gc&amp;type=alarm">alarm</a></code></pre>
      
    
 
      <pre><span><span class="keyword">val</span> delete_alarm</span> : <code class="type"><a href="?package=stdlib&amp;module=Gc&amp;type=alarm">alarm</a> -&gt; unit</code></pre>
      
    </div>